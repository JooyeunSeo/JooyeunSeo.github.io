---
excerpt: "'LeetCode: Reverse Bits' í’€ì´ ì •ë¦¬"
title: "\0190. Reverse Bits"
header:
  teaser: "https://assets.leetcode.com/static_assets/public/images/LeetCode_Sharing.png"
categories:
  - Leetcode-Easy
tags:
  - Coding Test
  - Python
  - Bit Manipulation
---

## <i class="fa-solid fa-file-lines"></i> Description

Reverse bits of a given 32 bits unsigned integer.

**Note:**

- Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
- In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">2's complement notation</a>. Therefore, in **Example 2** above, the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.


**Example 1:**

- Input: n = 00000010100101000001111010011100
- Output: 964176192 (00111001011110000010100101000000)
- Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.

**Example 2:**

- Input: n = 11111111111111111111111111111101
- Output: 3221225471 (10111111111111111111111111111111)
- Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.

**Constraints:**

- The input must be a **binary string** of length 32
<br>

**Follow up:** If this function is called many times, how would you optimize it?

## <i class="fa-solid fa-cloud-arrow-up"></i> Submitted Code

```python
class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):
        result = 0
        binary_str = bin(n)[2:].zfill(32)   # ìŠ¬ë¼ì´ì‹±ìœ¼ë¡œ ë§¨ ì• '0b' ì œê±° í›„ 32ë¹„íŠ¸ì— ë§ì¶° 0ìœ¼ë¡œ ì±„ì›€

        for i in range(32):
            result += int(binary_str[i]) * (2 ** i)

        return result
```
<i class="fa-solid fa-clock"></i> Runtime: **19** ms \| Beats **45.46%**    
<i class="fa-solid fa-memory"></i> Memory: **12.35** MB \| Beats **75.31%**

ì…ë ¥ê°’ nì´ 0ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ê²½ìš° int íƒ€ì…ìœ¼ë¡œ ê³„ì‚°í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— <mark>bin()</mark> í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ strìœ¼ë¡œ ë§Œë“¤ì–´ì•¼ í–ˆë‹¤. ê·¸ë¦¬ê³  <mark>zfill()</mark>ë¡œ ì•ì— 0ì„ ì±„ì›Œ 32ë¹„íŠ¸ ê¸¸ì´ë¡œ ë§ì·„ë‹¤.

## <i class="fa-solid fa-flask"></i> Other Solutions

### <a href="" target="_blank">1st</a>

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        res = 0
        for i in range(32):
            res = res << 1       # Shift left (make space for new bit)
            res += (n & 1)       # Add the least significant bit of n to res
            n = n >> 1           # Shift n to the right
        return res
```
<i class="fa-solid fa-clock"></i> **time complexity:** ğ‘‚(32)    
<i class="fa-solid fa-memory"></i> **space complexity:** ğ‘‚(1)           

ë¹„íŠ¸ ì—°ì‚°ì <mark><<</mark> ì™€ <mark>>></mark> ë¥¼ í™œìš©í•˜ë©´ ì•ì˜ '0b'ë¥¼ ì²˜ë¦¬í•˜ì§€ ì•Šì•„ë„ ëœë‹¤. ì—¬ê¸°ì„œëŠ” <mark>&</mark> ì—°ì‚°ìë¥¼ ì‚¬ìš©í•´ì„œ ê°€ì¥ ì˜¤ë¥¸ìª½ ë¹„íŠ¸ í•˜ë‚˜ë¥¼ ì¶”ì¶œí–ˆë‹¤(0ì¼ ê²½ìš° `0 & 1`ì€ 0, 1ì¼ ê²½ìš° `1 & 1`ì€ 1ì´ë˜ê¸° ë•Œë¬¸).

res = 0    
n = 0b11011010 (218)   
{: style="color: blue;"}
<pre>
i        n        res    res << 1    n & 1      res(new)    
0    11011010      0         0         0         0 + 0    
1     1101101      0         0         1         0 + 1
2      110110      1         2         0         2 + 0           
3       11011      2         4         1         4 + 1
4        1101      5        10         1         10 + 1
5         110     11        22         0         22 + 0
6          11     22        44         1         44 + 1
7           1     45        90         1         90 + 1
</pre>

res = 0b10110110 (91)
{: style="color: green;"}