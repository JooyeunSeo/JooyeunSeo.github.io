---
excerpt: "'LeetCode: Flood Fill' í’€ì´ ì •ë¦¬"
title: "\0733. Flood Fill"
header:
  teaser: "https://assets.leetcode.com/static_assets/public/images/LeetCode_Sharing.png"
categories:
  - Leetcode-Easy
tags:
  - Coding Test
  - Python
  - Array
  - Depth-First Search
  - Breadth-First Search
  - Matrix
  - Weekly Contest
---

## <i class="fa-solid fa-file-lines"></i> Description

You are given an image represented by an `m x n` grid of integers `image`, where `image[i][j]` represents the pixel value of the image. You are also given three integers `sr`, `sc`, and `color`. Your task is to perform a **flood fill** on the image starting from the pixel i`mage[sr][sc]`.

To perform a **flood fill**:

1. Begin with the starting pixel and change its color to `color`.
1. Perform the same process for each pixel that is **directly adjacent** (pixels that share a side with the original pixel, either horizontally or vertically) and shares the **same color** as the starting pixel.
3. Keep **repeating** this process by checking neighboring pixels of the updated pixels and modifying their color if it matches the original color of the starting pixel.
4. The process `stops` when there are **no more** adjacent pixels of the original color to update.

Return the `modified` image after performing the flood fill.

**Example 1:**

- Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2
- Output: [[2,2,2],[2,2,0],[2,0,1]]
- Explanation:    
![](https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg)      
From the center of the image with position `(sr, sc) = (1, 1)` (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.       
Note the bottom corner is **not** colored 2, because it is not horizontally or vertically connected to the starting pixel.

**Example 2:**

- Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0
- Output: [[0,0,0],[0,0,0]]
- Explanation:    
The starting pixel is already colored with 0, which is the same as the target color.    
Therefore, no changes are made to the image.

**Constraints:**

- m == image.length
- n == image[i].length
- 1 <= m, n <= 50
- 0 <= image[i][j], color < 2<sup>16</sup>
- 0 <= sr < m
- 0 <= sc < n

ğŸ’¡ **Hint 1:**   
<u><span style="color:#F5F5F5">Write a recursive function that paints the pixel if it's the correct color, then recurses on neighboring pixels.</span></u>

## <i class="fa-solid fa-cloud-arrow-up"></i> Submitted Code

```python
class Solution(object):
    def floodFill(self, image, sr, sc, color):
        """
        :type image: List[List[int]]
        :type sr: int
        :type sc: int
        :type color: int
        :rtype: List[List[int]]
        """
        self.rows = len(image)              # í–‰ ê°œìˆ˜
        self.cols = len(image[0])           # ì—´ ê°œìˆ˜
        self.target_color = image[sr][sc]   # ë°”ê¿”ì•¼ í•˜ëŠ” ìˆ«ì

        def search(r, c):
            if image[r][c] != self.target_color:
                return
            
            # ê°’ì´ target_colorë¼ë©´ colorë¡œ ë³€ê²½ í›„ 4ë°©í–¥ ì²´í¬
            image[r][c] = color

            if r > 0: search(r-1, c)            # ìœ„
            if r < self.rows-1: search(r+1, c)  # ì•„ë˜
            if c > 0: search(r, c-1)            # ì™¼ìª½
            if c < self.cols-1: search(r, c+1)  # ì˜¤ë¥¸ìª½

        if self.target_color != color:          # (sr, sc)ì˜ ê°’ì´ colorì™€ ê°™ë‹¤ë©´ í˜¸ì¶œ í•„ìš” ì—†ìŒ
            search(sr, sc)
        return image
```
<i class="fa-solid fa-clock"></i> Runtime: **0** ms \| Beats **100.00%**    
<i class="fa-solid fa-memory"></i> Memory: **12.77** MB \| Beats **26.64%**

íŠ¹ì •í•œ ìƒ‰ì´ ëŠê¸°ì§€ ì•Šê³  ì—°ê²°ëœ ë¶€ë¶„ì—ë§Œ ìƒˆë¡œìš´ ìƒ‰ì„ ì¹ í•´ì•¼ í•˜ëŠ” ë¬¸ì œë¡œ, DFSë¥¼ ì‚¬ìš©í–ˆë‹¤.

## <i class="fa-solid fa-flask"></i> Other Solutions

### <a href="https://leetcode.com/problems/flood-fill/solutions/2707985/python-flood-fill-algorithm-98-faster-by-ptxk/" target="_blank">1st</a>

```python
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        
        start_color = image[sr][sc]                 # colorë¡œ ë°”ê¿”ì•¼ í•  ê°’
        
        def flood_fill(x, y):
            if x < 0 or x >= len(image): return     # í–‰ ë²”ìœ„ ë²—ì–´ë‚˜ë©´ ë¦¬í„´
            if y < 0 or y >= len(image[0]): return  # ì—´ ë²”ìœ„ ë²—ì–´ë‚˜ë©´ ë¦¬í„´
            
            if image[x][y] == color: return         # ì´ë¯¸ colorì™€ ê°™ì€ ê°’ì´ë©´ ë¦¬í„´
            if image[x][y] != start_color: return   # ê°’ì´ start_colorì™€ ë‹¤ë¥´ë©´ ë¦¬í„´
            
            image[x][y] = color
            
            flood_fill(x-1, y)
            flood_fill(x+1, y)
            flood_fill(x, y+1)
            flood_fill(x, y-1)
        
        flood_fill(sr, sc)
        return image
```
<i class="fa-solid fa-clock"></i> **time complexity:** ğ‘‚(ğ‘š\*ğ‘›)    
<i class="fa-solid fa-memory"></i> **space complexity:** ğ‘‚(ğ‘š\*ğ‘›)           

ì¬ê·€ í˜¸ì¶œì— í•´ë‹¹í•˜ì§€ ì•ŠëŠ” ì¡°ê±´ë“¤ì„ ë¨¼ì € ëª¨ë‘ ì²´í¬í•´ì„œ ë¦¬í„´ì‹œí‚¤ëŠ” ë°©ë²•ë„ ìˆë‹¤.

### <a href="" target="_blank">2nd</a>

```python
class Solution(object):
    def floodFill(self, image, sr, sc, color):
        original = image[sr][sc]

        if original == color:
            return image

        seen = set()
        self.checkNeighbors(image, original, color, sr, sc, seen)
        return image

    def checkNeighbors(self, image, original, new, r, c, seen):
        seen.add((r, c))
        image[r][c] = new
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if (0 <= nr < len(image) and 0 <= nc < len(image[0]) and 
                image[nr][nc] == original and (nr, nc) not in seen):
                self.checkNeighbors(image, original, new, nr, nc, seen)
        
```
<mark>set()</mark>ì— ì´ë¯¸ ë°©ë¬¸í–ˆë˜ ì…€ì„ ì €ì¥í•´ì„œ ì¤‘ë³µ ìˆœíšŒë¥¼ ë§‰ì„ ìˆ˜ë„ ìˆë‹¤.