---
excerpt: "'LeetCode: Binary Gap' í’€ì´ ì •ë¦¬"
title: "\0868. Binary Gap"
header:
  teaser: "https://assets.leetcode.com/static_assets/public/images/LeetCode_Sharing.png"
categories:
  - Leetcode-Easy
tags:
  - Coding Test
  - Python
  - Bit Manipulation
  - Weekly Contest
---

## <i class="fa-solid fa-file-lines"></i> Description

Given a positive integer `n`, *find and return the **longest distance** between any two adjacent* `1`*'s in the binary representation of* `n`. *If there are no two adjacent* `1`*'s, return* `0`.

Two `1`'s are **adjacent** if there are only `0`'s separating them (possibly no `0`'s). The **distance** between two `1`'s is the absolute difference between their bit positions. For example, the two `1`'s in `"1001"` have a distance of 3.

**Example 1:**

- Input: n = 22
- Output: 2
- Explanation: 22 in binary is "10110".    
The first adjacent pair of 1's is "10110" with a distance of 2.    
The second adjacent pair of 1's is "10110" with a distance of 1.    
The answer is the largest of these two distances, which is 2.    
Note that "10110" is not a valid pair since there is a 1 separating the two 1's underlined.

**Example 2:**

- Input: n = 8
- Output: 0
- Explanation: 8 in binary is "1000".    
There are not any adjacent pairs of 1's in the binary representation of 8, so we return 0.

**Example 3:**

- Input: n = 5
- Output: 2
- Explanation: 5 in binary is "101".

**Constraints:**

- 1 <= n <= 10<sup>9</sup>

## <i class="fa-solid fa-cloud-arrow-up"></i> Submitted Code

```python
class Solution(object):
    def binaryGap(self, n):
        """
        :type n: int
        :rtype: int
        """
        idx = 0             # í˜„ì¬ ìë¦¬ìˆ˜ì˜ ì¸ë±ìŠ¤
        prev = None         # ì´ì „ 1ë¹„íŠ¸ì˜ ì¸ë±ìŠ¤
        max_distance = 0

        while n != 0:
            if n & 1 == 1:
                if prev is None:
                    prev = idx
                else:
                    max_distance = max(max_distance, (idx - prev))
                    prev = idx
            
            n >>= 1
            idx += 1
        
        return max_distance
```
<i class="fa-solid fa-clock"></i> Runtime: **0** ms \| Beats **100.00%**    
<i class="fa-solid fa-memory"></i> Memory: **12.49** MB \| Beats **52.54%**

& ì™€ >> ì—°ì‚°ìë¡œ ë’¤ì—ì„œë¶€í„° 1ë¹„íŠ¸ì”© ê²€ì‚¬í•˜ê³ , ì¸ë±ìŠ¤ë¥¼ ë¶™ì—¬ ê±°ë¦¬ë¥¼ ê³„ì‚°í–ˆë‹¤.

## <i class="fa-solid fa-flask"></i> Other Solutions

### <a href="https://leetcode.com/problems/binary-gap/solutions/149835/cjavapython-dividing-by-2-by-lee215-wq4o/" target="_blank">1st</a>

```python
    def binaryGap(self, N):
        index = [i for i, v in enumerate(bin(N)) if v == '1']
        return max([b - a for a, b in zip(index, index[1:])] or [0])
```
<i class="fa-solid fa-clock"></i> **time complexity:** ğ‘‚(logğ‘›) â† nì˜ ë¹„íŠ¸ ìˆ˜   
<i class="fa-solid fa-memory"></i> **space complexity:** ğ‘‚(logğ‘›)           

íŒŒì´ì¬ ë‚´ì¥ í•¨ìˆ˜ë¥¼ í†µí•´ ì •ìˆ˜ë¥¼ ì´ì§„ ë¬¸ìì—´ë¡œ ë³€í™˜í•´ì„œ í’€ ìˆ˜ë„ ìˆì§€ë§Œ ê³µê°„ íš¨ìœ¨ì„±ì€ ë¹„íŠ¸ë¥¼ ì§ì ‘ ì—°ì‚°í•˜ëŠ” ê²ƒë³´ë‹¤ ë–¨ì–´ì§„ë‹¤.

n = 22
{: style="color: blue;"}
<pre>
bin(N) = "0 b 1 0 1 1 0"
index  = [    2,  4,5  ]

                          a  b    a  b
zip(index, index[1:]) â†’ [(2, 4), (4, 5)]
                b - a â†’     2       1
                           max
</pre>

return 2
{: style="color: green;"}