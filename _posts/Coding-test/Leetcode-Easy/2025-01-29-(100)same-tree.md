---
excerpt: "'LeetCode: Same Tree' í’€ì´ ì •ë¦¬"
title: "\0100. Same Tree"
header:
  teaser: "https://assets.leetcode.com/static_assets/public/images/LeetCode_Sharing.png"
categories:
  - Leetcode-Easy
tags:
  - Coding Test
  - Python
  - Binary Tree
  - Depth-First Search
  - Stack
  - Breadth-First Search
---

## <i class="fa-solid fa-file-lines"></i> Description

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

- Input: p = [1,2,3], q = [1,2,3]
- Output: true

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)

- Input: p = [1,2], q = [1,null,2]
- Output: false

**Example 3:**

![](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)

- Input: p = [1,2,1], q = [1,1,2]
- Output: false

**Constraints:**

- The number of nodes in both trees is in the range [0, 100].
- -10<sup>4</sup> <= Node.val <= 10<sup>4</sup>

## <i class="fa-solid fa-cloud-arrow-up"></i> Submitted Code

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution(object):
    def isSameTree(self, p, q):
        """
        :type p: Optional[TreeNode]
        :type q: Optional[TreeNode]
        :rtype: bool
        """
        stack_rights = []
        while p or q or stack_rights:                           
            if (p is None or q is None) or (p.val != q.val):  # ë‘˜ ì¤‘ í•˜ë‚˜ê°€ Noneì´ê±°ë‚˜ ê°’ì´ ë‹¤ë¥´ë©´ false
                return False

            if p.right is not None and q.right is not None:   # ë‘˜ ë‹¤ ì˜¤ë¥¸ìª½ ìì‹ì´ ìˆìœ¼ë©´ ìŠ¤íƒì— ì¶”ê°€
                stack_rights.append((p.right, q.right))
            elif p.right is not None or q.right is not None:  # í•œ ìª½ë§Œ ì˜¤ë¥¸ìª½ ìì‹ ì¡´ì¬í•˜ë©´ false
                return False
            
            if p.left is not None and q.left is not None:     # ë‘˜ ë‹¤ ì™¼ìª½ ìì‹ì´ ìˆìœ¼ë©´ ì´ë™
                p = p.left
                q = q.left 
            elif p.left is None and q.left is None:           # ë‘˜ ë‹¤ ì™¼ìª½ ìì‹ì´ ì—†ê³ 
                if stack_rights:                                # ìŠ¤íƒì— ê°’ì´ ìˆë‹¤ë©´ pop
                    p, q = stack_rights.pop()
                else:                                           # ìŠ¤íƒì— ê°’ì´ ì—†ë‹¤ë©´ Noneìœ¼ë¡œ ë°˜í™˜
                    p = None
                    q = None
            else:                                             # í•œ ìª½ë§Œ ì™¼ìª½ ìì‹ì´ ì¡´ì¬í•˜ë©´ false
                return False                                  
        return True        
```
<i class="fa-solid fa-clock"></i> Runtime: **0** ms \| Beats **100.00%**    
<i class="fa-solid fa-memory"></i> Memory: **12.51** MB \| Beats **40.19%**

DFS (ê¹Šì´ ìš°ì„  íƒìƒ‰) ë°©ì‹ì„ ì‚¬ìš©í–ˆë‹¤. ì‹œê°„ ë³µì¡ë„ë¥¼ ìµœëŒ€í•œ ì¤„ì´ê³  ì‹¶ì–´ì„œ ì¬ê·€ í˜¸ì¶œ ëŒ€ì‹  ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„í•´ë´¤ë‹¤. íš¨ìœ¨ì€ ì¢‹ì•˜ì§€ë§Œ  ì½”ë“œê°€ ë„ˆë¬´ ê¸¸ì–´ì¡Œë‹¤.  

íŠ¸ë¦¬ ë…¸ë“œì˜ êµ¬ì¡°ë¥¼ ì¶œë ¥í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

`print(p)` ì˜ˆì‹œ
<pre>
e.g.1 â†’ TreeNode{
          val: 1,
          left: TreeNode{val: 2, left: None, right: None},
          right: TreeNode{val: 3, left: None, right: None}
        }
e.g.2 â†’ TreeNode{val: 2, left: None, right: None}
e.g.3 â†’ None
</pre>

- `p.val`ë¡œ val ê°’ë§Œ ì¶”ì¶œ ê°€ëŠ¥
- ë‘ ë…¸ë“œì˜ ê°’ì„ ë¹„êµí•˜ë ¤ë©´ val ê°’ë§Œ ì¶”ì¶œí•´ì•¼ í•œë‹¤(ë…¸ë“œ ìì²´ë¼ë¦¬ ë¹„êµí•˜ë©´ ì—ëŸ¬ ë°œìƒ)
- `None`ì¸ ë…¸ë“œì˜ val ê°’ì„ ì¶œë ¥í•˜ë ¤ í•  ê²½ìš° ì—ëŸ¬ ë°œìƒ

## <i class="fa-solid fa-flask"></i> Other Solutions

### <a href="https://leetcode.com/problems/same-tree/solutions/6129568/video-find-true-cases-by-niits-i06z/" target="_blank">1st</a>

```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q:               # both trees are empty
            return True
        
        if p and q and p.val == q.val:    # both trees are non-empty and have the same root value
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
        
        return False                      # none of the above conditions are met
```
<i class="fa-solid fa-clock"></i> **time complexity:** ğ‘‚(ğ‘›)    
<i class="fa-solid fa-memory"></i> **space complexity:** ğ‘‚(ğ‘›)    

ì¬ê·€ í˜¸ì¶œì„ ì´ìš©í–ˆìœ¼ë©°, ë‘ íŠ¸ë¦¬ê°€ ë™ì¼í•œ ì¼€ì´ìŠ¤ ë‘ ê°€ì§€ì¼ ê²½ìš°ë§Œ Trueë¥¼ ë°˜í™˜í•˜ê³  ë‚˜ë¨¸ì§€ëŠ” falseê°€ ë˜ëŠ” ì›ë¦¬ë‹¤.

1. ë‘ íŠ¸ë¦¬ê°€ ëª¨ë‘ ë¹ˆ íŠ¸ë¦¬ì¼ ê²½ìš°
2. ë‘ íŠ¸ë¦¬ê°€ ë¹„ì–´ ìˆì§€ ì•Šê³ , ê°’ì´ ê°™ì€ ê²½ìš°
   - ì¬ê·€ì ìœ¼ë¡œ ë‘ íŠ¸ë¦¬ì˜ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì™€ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ë¹„êµ
   - ì™¼ìª½ ìì‹ë“¤(ì„œë¸ŒíŠ¸ë¦¬)ê³¼ ì˜¤ë¥¸ìª½ ìì‹ë“¤ì´ ëª¨ë‘ Trueê°€ ë‚˜ì™€ì•¼ and ë¹„êµì—°ì‚°ìì˜ ê²°ê³¼ë„ True

### <a href="https://leetcode.com/problems/same-tree/solutions/4782580/two-dfs-solution-recursive-and-non-recursive/?envType=daily-question&envId=2024-02-26" target="_blank">2nd</a>

```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        stack = [(p, q)]          # ìŠ¤íƒì— ë‘ íŠ¸ë¦¬ì˜ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì¶”ê°€
        while stack:              # ìŠ¤íƒì´ ë¹Œ ë•Œê¹Œì§€ ë°˜ë³µ
            p, q = stack.pop()
            if p or q:
                if not p or not q or p.val != q.val:
                    return False
                stack.append((p.left, q.left))    # ì™¼ìª½ ìì‹ ë¹„êµ
                stack.append((p.right, q.right))  # ì˜¤ë¥¸ìª½ ìì‹ ë¹„êµ
        return True
```
ë‚´ê°€ ì œì¶œí–ˆë˜ ê²ƒì²˜ëŸ¼ ìŠ¤íƒì„ ì´ìš©í–ˆìœ¼ë‚˜, ì¢€ ë” ê°„ë‹¨í•œ ë°©ë²•ì´ì–´ì„œ ì°¸ê³ í–ˆë‹¤. ë‹¤ë§Œ ê°™ì€ ê¹Šì´ì—ì„œ ì™¼ìª½ ìì‹ë¶€í„° ë¹„êµí•˜ëŠ”ê²Œ ë” í¸í•´ì„œ ìŠ¤íƒì— ë„£ëŠ” ìˆœì„œë¥¼ ë³€ê²½í•˜ë©´ ë” ì¢‹ì„ ê²ƒ ê°™ë‹¤.

### <a href="https://leetcode.com/problems/same-tree/solutions/4784458/one-line-solution/" target="_blank">3rd</a>

```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        return str(p)==str(q)
```
TreeNode íƒ€ì…ì„ strë¡œ í˜•ë³€í™˜ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œê²Œ ëœ ë‹µì•ˆì´ì–´ì„œ ì°¸ê³ í–ˆë‹¤.

### <a href="https://leetcode.com/problems/same-tree/solutions/32894/python-recursive-solution-and-dfs-iterat-q8e4/" target="_blank">4rd</a>

```python
class Solution(object):
    def isSameTree(self, p, q):
        queue = [(p, q)]
        while queue:
            node1, node2 = queue.pop(0)
            if not node1 and not node2:
                continue
            elif None in [node1, node2]:
                return False
            else:
                if node1.val != node2.val:
                    return False
                queue.append((node1.left, node2.left))
                queue.append((node1.right, node2.right))
        return True
```
í(queue)ë¥¼ ì´ìš©í•œ ë„ˆë¹„ ìš°ì„  íƒìƒ‰ ë°©ì‹ìœ¼ë¡œë„ í’€ ìˆ˜ ìˆë‹¤. íŒŒì´ì¬ì˜ collections ëª¨ë“ˆì—ì„œ ì œê³µí•˜ëŠ” <mark>deque</mark>ë¡œ íë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

<div class="notice--info" markdown="1">
ğŸ’¡ **deque(ë±, Double-Ended Queue)**

```python
from collections import deque
```

- ì–‘ë°©í–¥ì—ì„œ ì‚½ì…/ì‚­ì œ ê°€ëŠ¥ â†’ `append()`, `appendleft()`, `pop()`, `popleft()`
- ë¦¬ìŠ¤íŠ¸ì˜ `pop()`ë³´ë‹¤ ë¹ ë¥¸ ì—°ì‚° ê°€ëŠ¥
- ìŠ¤íƒê³¼ í ëª¨ë‘ êµ¬í˜„ ê°€ëŠ¥
</div>