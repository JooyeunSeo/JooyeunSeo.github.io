---
excerpt: "C언어의 포인터 개념 정리"
title: "Pointer"
header:
  teaser: ""
categories:
  - Cheatsheet
tags:
  - C
last_modified_at: YYYY-MM-DDT00:30:30+09:00
---

## Memory and Address

- 메모리에는 **1byte** 단위로 위치를 식별 가능한 물리적인 주소값이 존재한다.
- 주소 범위: 0 - 2<sup>32</sup>(32bits) 또는 0 - 2<sup>64</sup>(64bits)
- 주소 표기: 16진수(e.g. 0x100, 0x104, …)
- 주소 특성: 주소는 이미 정해진 값으로, 변경할 수 없기 때문에 **상수**이다.
- 메모리에 접근하는 방법 2가지
   1. **식별자** 사용
      - 식별자는 메모리 공간에 붙여진 이름(변수명, 배열명, 구조체명, 함수명 등)이다.
      - 이름을 사용하여 메모리에 값을 저장하거나 저장된 값을 꺼내어 사용할 수 있다.
   2. 실제 **주소값**(포인터) 사용
      - 프로그램을 실행할 때마다 로딩 위치가 달라지기 때문에 직접 주소를 고정시킬 수는 없다.
      - `&` 연산자를 사용해 식별자가 가진 `시작 주소값(첫 번째 byte)`을 얻을 수 있다.

## Variable

```c
// int형 변수 선언(4byte)
int a = 10;
int b = 11; 

// 1. 변수의 포인터 구하기 → 변수명 앞에 주소연산자 &
printf("a의 포인터 : %p\n", &a);    // 100 (a의 시작 주소값 예시)
printf("b의 포인터 : %p\n", &b);    // 104 (b의 시작 주소값 예시)

// 2. 포인터가 가리키는 메모리를 사용(참조)하기 → 포인터 앞에 참조연산자 *
*&b = 20;
printf("b에 저장된 값 : %d\n", b);   // 20 (포인터로 저장된 값)

int c = *&b;
printf("c에 저장된 값 : &d\n", c);   // 20 (포인터로 꺼내온 값)

// 3. 포인터 저장하기 → 주소를 저장하는 포인터 변수 생성
int *pa;                          // int형을 가리키는 포인터 변수
pa = &a;                          // a의 주소를 pa에 배정
*pa = 1;                          // pa가 가리키는 메모리(a)에 값 저장
printf("pa 사용 : &d\n", *pa);     // 1


```


## 1d Array

```c
// 길이 3 1차원 배열 arr 선언
int arr[3] = {1,2,3};

// 배열 첫 번째 원소를 가리키는 포인터 변수 선언
int* p;             

// 포인터 변수에 주소 배정하는 2가지 방법
p = &arr[0];  // 1. 주소 연산자로 'arr의 첫 번째 원소'의 주소 넘기기
p = arr;      // 2. 배열명 'arr'는 배열의 시작 주소 '&arr[0]'로 자동 변환됨
```

<pre>
arr  → 100번지  104번지  108번지 
     [   1   |   2   |   3   ]
       4byte   4byte   4byte
------------------------------

<arr+i → i번째 원소의 주소>
arr   == p   == &arr[0] == 100번지
arr+1 == p+1 == &arr[1] == 104번지
arr+2 == p+2 == &arr[2] == 108번지

<주소 arr+i가 가리키는 값 간접 참조 → i번째 원소 값>
*(arr+0) == *(p+0) == arr[0] == 1  == *arr
*(arr+1) == *(p+1) == arr[1] == 2
*(arr+2) == *(p+2) == arr[2] == 3
</pre>

## Array Pointer with 2d Array

```c
// 2행 3열 2차원 배열 arr2 선언
int arr2[2][3] = { {1, 2, 3}, {4, 5, 6} };

int (*pp)[3];  // 열 3개짜리 배열 포인터 (길이가 3인 행 하나를 가리켜야 하기 때문)
pp = arr2;     // arr2 == &arr2[0] (2차원 배열에서 인덱스 1개만 사용하면 행 시작 주소)
```

<pre>
           0열         1열          2열
0행   [[ 1(100번지) | 2(104번지) | 3(108번지) ]
1행    [ 4(112번지) | 5(116번지) | 6(120번지) ]]
--------------------------------------------

    pp       == &arr2[0] == 0행 시작 주소
    pp+1     == &arr2[1] == 1행 시작 주소 (int열 3개짜리, 12byte만큼 증가)

  *(pp)      == 0행 자체 == 0행 시작 주소
  *(pp+1)    == 1행 자체 == 1행 시작 주소

  *(pp+1)+0  == &arr2[1][0] == 1행 0열 주소
  *(pp+1)+1  == &arr2[1][1] == 1행 1열 주소

*(*(pp+1)+0) == arr2[1][0] == 1행 0열 값 = 4
*(*(pp+1)+1) == arr2[1][1] == 1행 1열 값 = 5
</pre>

## Pointer Array & Double Pointer

```c
// 길이 3인 포인터 배열 선언(배열 포인터 선언 형식에서 괄호만 뺀 형태)
char *ary[3] = {"fig", "pear", "apple"};

// 이중 포인터
char **ptr_ary = ary;   // ary의 시작 주소
```

<pre>
50번지 
 ary   [ 100번지 | 110번지 | 120번지 ]
           ↓        ↓        ↓
          fig     pear     apple
-----------------------------------

  ptr_ary         == &ary[0] == 50번지
  ptr_ary+1       == &ary[1]

  *(ptr_ary)      == "fig"  문자열 시작 주소 == 100번지
  *(ptr_ary+1)    == "pear" 문자열 시작 주소 == 110번지

  *(ptr_ary)+0    == "fig"  1번째 문자 'f' 주소 == 100번지
  *(ptr_ary+1)+1  == "pear" 2번째 문자 'e' 주소 == 111번지

*(*(ptr_ary)+0)   == 문자 'f' 
*(*(ptr_ary+1)+1) == 문자 'e'
</pre>


<br><br>
<center>References</center>

1. 『』
{: .small}
